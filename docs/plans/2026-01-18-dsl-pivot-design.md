# DSL Pivot Design

**Date:** 2026-01-18
**Status:** Draft
**Scope:** Pivot mantis_core to business metrics reporting with custom DSL and Typst output

## Overview

Transform mantis_core from a Lua-based semantic layer into a business metrics reporting tool with:
- Custom DSL (defined in `docs/semantic-model-dsl-spec-v3.1.md`)
- Typst-based PDF output
- Analyst-friendly concepts: atoms, times, slicers (not facts/dimensions)

## Key Decisions

### Output Modes
**Both Typst source and compiled PDFs** - Use the `typst` Rust crate for native compilation. Users can inspect/customize `.typ` files or get PDFs directly.

### Execution Model
**CLI + Library** - Primary CLI interface, clean library API for embedding. Future: long-running report server (like SSRS, but lighter).

### Data Connections
**Existing Go worker** - Unchanged. NDJSON over stdin/stdout. Rust generates SQL, worker executes against databases.

### LSP Strategy
**Replace entirely** - New parser for new DSL. LSP comes later once syntax stabilizes. Phase: CLI-only first.

### File Organization
**Flexible** - Single `.mantis` file for small projects, multi-file with auto-discovery (`**/*.mantis`) for larger ones.

### Parsing
- **Chumsky** for DSL grammar (error recovery, spans for LSP)
- **sqlparser-rs** for SQL expressions inside `{ }` blocks
- **Context7** for latest chumsky documentation during implementation

### Typst Integration
**Variables approach** - Mantis generates a wrapper `.typ` file that sets variables and imports a template. Templates stay pure (no hardcoded column indices). CSV contains the data.

```typ
// Generated by Mantis
#let data_path = "report_data.csv"
#let month_labels = ("Feb 24", "Mar 24", ...)
#let col_target = 2
#import "@local/mantis-reports:1.0.0": rolling_dashboard
#rolling_dashboard()
```

## Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                              mantis_core                                │
├─────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌──────────┐ │
│  │   Parser    │    │  Semantic   │    │    SQL      │    │  Typst   │ │
│  │  (chumsky)  │───▶│   Model     │───▶│ Generation  │───▶│  Output  │ │
│  │             │    │             │    │  (existing) │    │          │ │
│  └─────────────┘    └─────────────┘    └─────────────┘    └──────────┘ │
│         │                 │                   │                 │      │
│         ▼                 ▼                   ▼                 ▼      │
│   DSL AST with      Model Graph        Multi-dialect      CSV + .typ  │
│   Span info         Join paths         SQL strings        wrapper     │
│                     Validation                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                          Go Worker (unchanged)                          │
│                    Query execution, DB connections                      │
└─────────────────────────────────────────────────────────────────────────┘
```

### What Stays
- `src/sql/` - Multi-dialect SQL generation
- `src/worker/` - Go worker communication
- `src/semantic/model_graph/` - Relationship traversal, join path finding
- `src/semantic/planner/` - Query planning phases (adapt, don't rewrite)

### What Gets Replaced
- `src/model/loader/lua.rs` - Replace with chumsky parser
- `src/lsp/` - Gut and rebuild for new DSL (later phase)

### What's New
- `src/dsl/` - Parser, AST, validation, lowering
- `src/typst/` - CSV shaping, wrapper generation, PDF compilation
- `src/cli/` - Command handlers
- `src/bin/mantis.rs` - CLI entry point

## DSL Parser Design

### Module Structure
```
src/dsl/
├── mod.rs           # Public API: parse_file, parse_string
├── lexer.rs         # Token types (keywords, symbols, identifiers)
├── ast.rs           # AST node types with Span wrappers
├── parser.rs        # Chumsky grammar combinators
├── sql_expr.rs      # Bridge to sqlparser-rs for { } blocks
└── validation.rs    # Semantic validation
```

### LSP-Ready Design

Every AST node carries span information. Parser uses chumsky's error recovery to continue after errors, producing partial ASTs with diagnostics.

```rust
pub struct ParseResult {
    pub model: Option<Model>,
    pub diagnostics: Vec<Diagnostic>,
}

pub struct Diagnostic {
    pub span: Span,
    pub severity: Severity,
    pub message: String,
    pub related: Vec<(Span, String)>,
}
```

### Symbol Table

Built during resolution pass for LSP features (go-to-definition, find references, rename):

```rust
pub struct SymbolTable {
    pub calendars: HashMap<String, Span>,
    pub dimensions: HashMap<String, DimensionSymbol>,
    pub tables: HashMap<String, TableSymbol>,
    pub measures: HashMap<String, MeasureSymbol>,
    pub references: Vec<Reference>,
}
```

### SQL Expression Handling

When parser hits `{ ... }`, extract raw string and span, validate with sqlparser-rs:

```rust
pub struct SqlExpr {
    pub raw: String,
    pub parsed: sqlparser::ast::Expr,
    pub span: Span,
    pub inner_offset: usize,  // For position mapping
}
```

### Error Recovery Patterns (from chumsky docs)

- `recover_with(via_parser(...))` - Custom recovery producing error nodes
- `skip_then_retry_until(...)` - Skip bad tokens until delimiter
- `nested_delimiters(...)` - Recover within balanced `{ }`

## Semantic Model Integration

New `SemanticModel` struct bridges DSL AST to existing infrastructure:

```rust
pub struct SemanticModel {
    pub calendars: HashMap<String, Calendar>,
    pub dimensions: HashMap<String, Dimension>,
    pub tables: HashMap<String, Table>,
    pub measures: HashMap<String, MeasureSet>,
    pub reports: HashMap<String, Report>,
    pub graph: ModelGraph,  // Reuse existing
}
```

Lowering: `dsl::Model` → `SemanticModel` → populate `ModelGraph` → use existing planner.

## CLI Design

```
mantis <command> [options]

Commands:
  check <file>          Parse and validate model
  run <report>          Execute report, output CSV + Typst
  render <report>       Execute and compile to PDF

Options:
  -m, --model <path>    Model file or directory
  -o, --output <path>   Output directory
  -c, --connection <name>  Connection from config
  --format <fmt>        csv, typst, pdf
  --period <expr>       Override report period
```

## Implementation Phases

### Phase 1: DSL Foundation (Current Scope)
- Set up `src/dsl/` module structure
- Chumsky parser skeleton with error recovery
- Lexer (keywords, symbols, identifiers, string literals)
- Parse core constructs: defaults, calendar, dimension, table, measures, report
- SQL expression bridge to sqlparser-rs
- Span tracking on all AST nodes
- Basic validation (undefined references)
- Tests against DSL spec examples

### Phase 2: Semantic Model Bridge
- Lowering from DSL AST to SemanticModel
- Populate ModelGraph from DSL
- Adapt measure resolution for @atom syntax
- Wire up to existing query planner

### Phase 3: Report Execution
- Period expression evaluation
- Time intelligence suffix expansion
- Report → SQL planning
- Worker execution integration
- Result shaping for Typst

### Phase 4: Typst Output & CLI
- CSV output formatting
- Typst wrapper generation
- typst crate integration for PDF
- CLI commands (check, run, render)

### Phase 5: Polish
- Error messages with spans and suggestions
- Multi-file model support
- Template resolution
- Documentation

## Cleanup Plan

### Remove
- `src/model/loader/lua.rs`
- `src/model/loader/sql_expr.rs`
- `src/lsp/` internals (keep structure for later)

### Adapt
- `src/model/` types for new DSL field names
- `src/semantic/planner/` for `@atom` measure syntax

### Keep Unchanged
- `src/sql/`
- `src/worker/`
- `src/semantic/model_graph/`
